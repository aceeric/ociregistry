#!/usr/bin/env bash
#
# This supports the registry serving an image created by 'docker save'. When you docker
# save an image to a tarball the layer SHA values don't match the SHA produced from the
# layer by executing for example 'sa256sum <sha>/layer.tar'. So clearly the SHA produced
# for the layer by 'docker save' has some other purpose that I don't understand. When I capture
# the HTTP traffic created by 'crane pull docker.io/hello-world:latest' the layer SHA values
# in the manifest from DockerHub differ from those in the tarball produced by 'docker save'
# but they *do* match the sa256sum value of the layer. Since this little OCI Registry pull-only
# server relies on layer SHAs matching the SHA of the layer, this little script "fixes" that
# for the server. The use case is:
#
# 1) mkdir -p images/library/hello-world/latest
# 2) docker pull docker.io/hello-world:latest
# 3) docker save hello-world:latest -o hello-world-latest.tar
# 4) tar -xf hello-world-latest.tar -C images/library/hello-world/latest
# 5) hack/fix-sha images/library/hello-world/latest
#
# If you look at the directores before and after, and the manifest.json file you will see that
# all the SHA refs were modified. At this point, this image can be served by the server.
#
# This script is only needed to serve images created by 'docker save'. In my testing, images
# obtained using 'crane pull' were usable as-is without any fiddling with.
#

image_root=$1

find $image_root -type f -name 'layer.tar' | while read layer; do
  newsha256=$(sha256sum $layer | awk '{print $1}')
  curdir=$(dirname $layer)
  cursha256=$(basename $curdir)
  mvdir="$(dirname $curdir)/$newsha256"
  #echo "LAYER=$layer"
  #echo "CURSHA=$cursha256"
  #echo "NEWSHA=$newsha256"
  #echo "CURDIR=$curdir"
  #echo "MVDIR=$mvdir"
  mv $curdir $mvdir
  sed -i -e "s/$cursha256/$newsha256/" $image_root/manifest.json
done
